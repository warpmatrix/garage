<!-- omit in toc -->
# 数据的表示和运算

## 1. 数值和编码

数制和相互转换的相关概念：

- 基数 $b$：每个数位所用的数码个数
- 位权 $w_i = b^i$：数位的权重（与数位和基数相关）
- 混合数：既包含整数又包含小数

数字的表示：$num = \sum_i a_i b^i$

不同进制之间的转换：

- 2, 8, 16 进制之间的相互转换
- 其它进制转换为十进制
- 十进制转换为其它进制
  - 整数部分使用除基取余法
  - 小数部分使用乘基取余法

> 十进制的有限小数不一定可以用二进制小数精确表示，二进制小数可以用十进制小数精确表示

机器数：数符和数码一起编码。常用编码方式：原码、补码、反码。

> 十进制数的二进制编码方式

ASCII 码：7 位二进制编码。33 个控制字符，95 个可印刷字符

- 汉字的编码使用两个字节表示：区位码、国标码、汉字内码
  - 国标码 = $($ 区位码 $)_{16}$ + 2020H
  - 汉字内码 = $($ 国标码 $)_{16}$ + 8080H

> 校验码的表示和使用

## 2. 定点数的表示

定点数的分类：

- 无符号数和有符号数
- 定点小数和定点整数

定点数的表示方法：

- 原码：最高位为符号位，其余为表示数的绝对值
  - 定点小数：$-1 + 2^{-n+1} \sim 1 - 2^{-n+1}$
  - 定点整数：$-2^{n-1} - 1 \sim 2^{n-1} - 1$
  - 零有两个种原码的表示方式
  - 正数表示为自身，负数表示为自身的相反数求余
- 补码：正数表示为自身，负数表示为自身求余
  - 定点小数：$-1 \sim 1 - 2^{-n + 1}$
  - 定点整数：$-2^{n-1} \sim 2^{n-1} - 1$
  - 负数求补码的方法：原码的数值部分取反加一
    - 也可以用于通过补码求原码
    - 补码：取反得到的码，真值的范围和原码保持相同（零也同样有两种表示方式）
  - 通过补码求相反数的补码：全部位取反加一
  - 算术移位的实现：符号位和数值位一起移动，符号位应保持不变
  - 变形补码（模 4 补码）：00 表示正，11 表示负，01 表示正溢出，10 表示负溢出
    - 用于 ALU 部件中
- 移码：使用真值加偏移值表示数据
  - 移码保持了原数据的单调性
  - 移码和补码相比，符号位相反

## 3. 定点数的运算

移位运算：

- 逻辑移位视为逻辑操作：对移位产生的空位直接补零
- 算术移位：移位得到的结果符合算术特性
  - 正数直接补零
  - 负数：原码补零，反码补一
    - 补码右边符合原码规律，左移补零
    - 补码左边符合反码规律，右移补一
- 循环移位：分为是否带 CF 进位标志位的循环移位
  - 用于低字节和高字节的数据互换

加减法运算：原码需要判断符号位进行处理，补码直接相加

符号扩展：原码补零，反码补一

- 补码整数在左边进行扩展补一
- 补码小数在右边进行扩展补零

溢出判断：超过上限（上溢），超过下限（下溢）

- 溢出产生的条件：符号相同的数相加、符合相异的数相减（使用加法实现）
- 操作数符号相同，并与结果的符号不同
- 使用双符号位进行判断，两个符号位相异表示溢出
- 符号位的进位和最高数位的进位相同说明没有溢出，不同说明存在溢出

乘法运算：

- 原码：符号位异或，数值部分进行乘积
  - 被乘数和乘数的各个位置相乘（右移相加）
  - ACC：存储加法结果和乘积高位
  - MQ：存储乘数和乘积的低位（随着运算的进行而右移）
  - X：存储被乘数与 ACC 进行加法
- 补码：增加辅助位，依据辅助位（最低位）减次低位的值加对应的补码
  - 运算过程使用双符号位

除法运算：

- 原码：恢复余数法，机器字长为 n 位，左移 n - 1 次，上商 n 次
  - 默认先商 1。被除数减除数为负数，加上除数相反数的补码并恢复余数
- 原码：加减交替法，利用余数的正负性判断商的取值
  - 发现余数错误直接左移加上除数得到下一位的商
  - 商的符号位和余数相同：被除数和除数的符号位进行异或
  - 左移 n - 1 次，上商 n 次，最后一步可能需要恢复余数
- 补码：加减交替法，利用余数和除数是否同号判断商的取值
  - 符号位参与运算，被除数、除数、余数使用双符号位表示
  - 末位恒置为 1，最后的余数即使符号不正确也不需要进行恢复操作

强制类型转换：

- 有符号和无符号数字的转换：不改变数据内容，仅改变数据的解释方式
- 大字长转换为小字长：直接将高位进行截断
- 小字长转换为大字长：进行符号拓展

数据的存储方式：大端存储、小端存储

数据的对齐问题：对齐存放和不对齐存放

- 对齐存放本质是空间换时间，不对齐存放可能导致一个指令两次访存

## 4. 浮点数的表示和运算

$N = (-1)^s M r^E$

- $s$ 为符号位，$M$ 为尾数，$E$ 为阶码，$r$ 为阶码的底

浮点数的表示范围：$n$ 为尾数的位数（包括符号位）

- 原码规格化的正数：$1 / 2 \leq M \leq (1 - 2^{-(n-1)})$
- 补码规格化的正数：$1 / 2 \leq M \leq (1 - 2^{-(n-1)})$
- 原码规格化的负数：$-(1 - 2^{-(n-1)}) \leq M \leq -1 / 2$
- 补码规格化的负数：$-1 \leq M \leq -(1 / 2 + 2^{-(n-1)})$

浮点数的加减运算步骤：对接、尾数求和、规格化、舍入、溢出判断

- 舍入处理：
  - 0 舍 1 入：可能造成二次溢出
  - 恒置 1：结合正负两种情况，可能变大可能变小，概率不均等
  - 朝偶数舍入：变大变小概率均等，IEEE 默认
- 浮点数的溢出处理：
  - 上溢：超过最大阶码，中断处理
  - 下溢：小于最小阶码，按零处理

强制类型转换优先级：

- char -> int -> long -> double
- float -> double

## 5. 算术逻辑单元

一位全加器：

- 和：$S_i = A_i \oplus B_i \oplus C_i$
- 进位：$C_i = A_iB_i + (A_i \oplus B_i) C_{i-1}$

并行加法器的进位构成进位链：

- 串行进位：行波进位，进位信号逐级形成
  - $C_i = A_iB_i + (A_i \oplus B_i) C_{i-1}$
- 并行进位：先行进位，利用各级 $A_iB_i$ 直接传送到高级加法器，加速进位的计算
  - $C_n = \sum_{i=1}^n(A_iB_i \prod_{j=i+1}^n(A_j \oplus B_j)) + C_0\prod_{i=1}^n(A_i \oplus B_i)$
    - $C_n = G + C_0P$
    - $G = \sum_{i=1}^n(A_iB_i \prod_{j=i+1}^n(A_j \oplus B_j))$
    - $P = \prod_{i=1}^n(A_i \oplus B_i)$
  - 随着级数的增加，电路逐渐复杂，引入分组并行进位
  - 单级先行进位方式：组内并行，组间串行
  - 多级先行进位方式：组内并行，组间并行（BCLA 电路）
    - $C_{bi} = \sum_{i=1}^n (G_i^*\prod_{j=i+1}^nP_i^*) + C_{b(i-1)} \prod_{i=1}^nP_i^*$

算术逻辑单元的标志信息：

- OF = $C_n \oplus C_{n-1}$
- CF = $C_{out} \oplus C_{in}$
- ZF = $\overline{\sum_i s_i}$

## 6. 一些 CSAPP 上的补充

- 现代 64 位的计算机，一般只有 47 位可用的内存空间大小
- 使用虚拟内存进行管理，逻辑实现 64 位的内存

浮点数的表示：S + Exp + frac

- num = $(-1)^s M 2^E$
- 浮点数是小数在取值范围和精度之间权衡的结果
- 在不同的区间使用不同的编码方式：-NaN, -$\infty$, -Normalized, -Denorm, -0, +0, +Denorm, +Normalized, +$\infty$, +NaN
- 使用上述编码方式，而不使用补码编码 $M$ 和 $E$ 的原因：相同符号的浮点数之间进行比较可以直接作为无符号整数进行比较（包括无穷大）
  - 使用偏移来表示阶数，可以通过阶数直接比较浮点数
  - 阶数相等时可以直接比较 frac
- 标准化的浮点数：normal
  - E = Exp - Bias 偏置编码法
    - Bias = $2^{k-1} - 1$
    - exp 不能取 $0$ 和 $2^k-1$
    - 偏置的选择方法：将 $E_{min}$ 转换为 1
  - M = 1.frac 隐含编码法
    - $m$, mantissa 尾数
    - 表示范围：$[1, 2-\epsilon] \rArr [1,2)$
    - get one more bit for free
- 非规格化的浮点数：denormal
  - exp 取 0 的情况，E = 1 - Bias
  - frac 取 0 表示 0，通过符号位可以区分 +0 和 -0
  - frac 非 0 表示最接近 0 的浮点数，没有隐含的前导 1
- exp 取 $2^k - 1$ 表示 INF(除 0 错误) 和 NAN (非法运算)

舍入规则：朝零舍入、向下舍入、向上舍入、**向偶数舍入** (IEEE default)

- 0.5 的情况各有 50% 的几率向上或向下舍入
- 其它情况正常舍入

计算机浮点数的运算规则：

- 存在舍入误差没有结合律、有交换律、形成闭环
- 加法、乘法有单位元，加法几乎都有逆元，几乎都满足单调性
- 乘法不满足分配律

## 7. 其它补充内容

校验码：利用冗余码发现和自动纠错的数据编码（检错纠错编码）

- 码距：两个合法码字之间的距离
- 码距大于等于 2 的数据校验码，开始具有检错能力

不同的校验码：

- 奇偶校验码：奇校验/偶校验。只能检奇数位的错误，且不能确定错误位置和纠错，用于对数据进行检查
- 海明校验码：通过多为校验码确定一组数据中出错的位数
  - 确定校验码的位数：$n + k + 1\leq 2^k$
  - 假设只出现一位错误或者不出错，校验位所有的状态可以包含上述的 $n + k + 1$ 的所有情况
  - 每一个校验位检查 1 位对应的一组数据，校验位位于一组的第一位
  - 有全校验位的海明码的校验效果：1 位纠错能力，2 位检错能力
- 循环冗余校验码：利用提前决定的生成多项式，对编码的信息位进行模 2 除法
  - 得到的余数置于信息位后面，用于检错和纠错
  - 重新计算得到的余数为 0，说明信息无差错
  - 重新计算得到的余数不为 0，余数指示信息出错的位置

BCD 码：使用 4 位二进制数表示 1 位十进制数。总共有 6 种冗余状态，可以根据不同的冗余状态设计不同的编码方式

- 8421 码：有权码，两个码组进行相加得到结果可能大于 9，需要进行修正（+6）
- 余 3 码：无权码，8421 码的基础上加 3
- 2421 码：有权码，大于 4 的数最高位为 1
