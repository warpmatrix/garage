# 存储系统

考试重点内容，特别是 cache 和虚拟存储器

## 存储器概述

存储器的分类：

- 主存：内存，CPU 直接随机进行访问，速度快容量小价格高，通常由 RAM 和 ROM 组成
- 辅存：外存，存储暂时不用的数据和永久保存的信息，不能与 CPU 直接交换信息
- 高速缓存：cache，存取速度和 CPU 的速度可比

存取方式的分类：

- 随机存储器 RAM：支持随机地址存取，存取时间和物理位置无关，读写灵活易于修改，存放用户程序
- 只读存储器 ROM：部分只读存储器可以通过电擦除的方式重新修改内容，存放系统程序
- 串行访问存储器：顺序存取存储器、直接存取存储器

信息可保存性的分类：

- 易失性存储器：断电后无法保持信息
- 非易失性存储器：断电后仍保持信息
- 破坏性读出：读出时存储信息被破坏，通常加入数据再生的操作恢复数据
- 非破坏性读出：读出后数据不被破坏

存储器的性能指标：大容量、低成本、高速度

- 存储容量、单位成本
- 存储速度：存取时间（读出时间、写入时间）、存取周期、主存带宽
  - 存取时间：操作开始到操作完成
  - 存取周期：操作开始到下一次操作开始
  - 存取周期大于存取时间（数据恢复操作）

存储体的构成：

- 存储元：存储一个二进制位
- 存储单元：多个存储元构成一个地址的存储内容
- 存储体：多个存储单元的集合

存储器的层次化结构：CPU（寄存器） -> cache -> 内存 -> 外存

- 缓存解决 CPU 和内存速度不匹配的问题，外存解决存储系统的容量问题
- CPU、缓存、内存可以相互交换信息，外存需要通过内存和 CPU 交换信息
- 核心思想：上层存储器作为下层存储器的高速缓存
  - 速度接近上层存储器，容量和价格接近下层存储器
- cache 的调度由硬件完成对所有程序员透明，内存的调度由硬件和操作系统完成对应用程序员透明

## 主存储器 (Main Memory)

内存主要由 DRAM 实现，cache 由 SRAM 实现

- SRAM 双稳态触发器存储信息，非破坏性读出，速度快成本高功耗大
- DRAM 电容存储信息，密度高易集成，地址复用，速度没有 SRAM 快且需要刷新
  - 刷新策略：集中刷新、分散刷新、异步刷新，默认的刷新周期（2ms）
    - 集中刷新：使用一整段时间进行刷新
    - 分散刷新：每一个工作周期都进行一次刷新操作
    - 异步刷新：将刷新操作分散到刷新周期中
  - 地址复用：地址分行和列两次传送

存储器芯片组成：存储器、译码器、IO/片选/读写控制电路

DRAM 读周期的几个概念：

- 读出时间 $t_A$：给出地址到读出数据
- 片选保持时间 $t_{CO}$：给出地址后设置片选，直至数据输出稳定
- 读周期 $t_{RC}$：两次读操作之间的间隔

ROM 的特点：结构简单、位密度高、非易失性

ROM 的类型：MROM、PROM、EPROM、Flash Memory、SSD

主存的基本组成：存储矩阵、地址寄存器、地址译码器、数据线、读写控制电路

内存和 CPU 的连接：数据总线、地址总线、控制总线

- 数据总线的位数和工作频率正比于传输速率，可以通过位扩展与之匹配
- 地址总线的位数决定最大可寻址空间，可以通过字扩展与之匹配
- 控制总线指出总线周期类型和操作完成时刻，通常可以和内存直接相连

内存容量的扩展方式：

- 位扩展：共用地址线和控制线，并联数据线
- 字扩展：共用数据线、控制线和低位地址线，将高位地址线作为片选信号（两种片选方式）
  - 线选法：高位地址线和芯片的片选端直接相连，地址空间不连续，需要增加芯片的片选端接口数量解决
  - 译码片选法：通过多路复用器进行片选
- 字位同时扩展

双端口 RAM：空间并行处理，允许两个控制器同时异步访问存储单元

- 访问同一地址且存在写操作发生错误：写入错误（两个写操作）、读出错误（一个读操作一个写操作）
- 通过 busy 信号对其中一个操作进行延时解决冲突

多模块存储器：时间并行处理，CPU 一次访问内存获得多个数据，增加了存储器的带宽

- 单体多字存储器：一个存储体中每个存储单元存储多个字，需要指令和数据连续存放
- 多体并行存储器：一个存储器中包含多个存储体，既能并行工作也能交叉工作
  - 高位交叉编址：高位表示体号，低位为体内地址。访问连续的内容仍在同一个存储体进行无法并行访问
  - 低位交叉编址：低位表示体号，高位为体内地址。交叉编址，连续的内容存储在相邻的模块中，采用流水线的方式存取
    - 存储器交叉模块数不小于 $m = T / r$
    - $m$ 为交叉存取度，$T$ 为一个字的存取周期，$r$ 为总线传送周期
    - 连续存取 $m$ 个字所需的时间 $t_m = T + (m-1)r$

## 高速缓冲存储器 (Cache)

局部性原理：程序和数据的访问都可能反应局部性

- 时间局部性：最近未来使用到数据，可能是现在使用的数据
  - 程序中存在大量的循环操作，重复执行或使用相同的指令和数据
  - 回答时间局部性的问题，从数据的访问次数出发
- 空间局部性：最近未来使用到数据，可能和现在使用的数据邻近
  - 指令通常顺序存放，数据通常以数组、表等形式聚簇存放
  - 回答空间局部性的问题，从访问顺序和空间顺序的角度出发（相邻访问元素之间的距离）

Cache：由 SRAM 组成

- 和内存保持相等的分块大小，块数比内存小
- Cache 中一行的内容：标记 | 有效位 | 块的内容
- **有效位**标记 cache 信息是否有效（开机初始化？）
- cache 命中直接进行读写操作，不命中从内存调入（可能用到置换算法）
- CPU 和 cache 交换数据以字为单位，内存和 cache 交换数据以块为单位
- 命中率 $H = N_c / (N_c + N_m)$
- 平均访问时间 $T_a = Ht_c + (1-H)t_m$
- cache 和内存的访问可以同时进行，当 cache 命中后可以中断内存的访问操作

Cache 和内存的地址映射：将内存的地址映射到 Cache 的地址

- 直接映射：使用内存块号中的低 $c$ 位进行映射，内存块号的高位需要用来标记
  - $j = i \operatorname{mod} 2^c$
  - 内存地址 = 标记 | cache 块号 | 块内地址
  - 发生冲突直接进行替换操作，冲突概率高，空间利用率低
- 全相联映射：内存的每一块都可以装入 cache 的任意位置
  - 标记记录内存块号，CPU 访问数据时需要比较所有的 cache 块的标记
  - 内存地址 = 标记 | 块内地址
  - 存取灵活、冲突概率低、空间利用率高、命中率高
  - 比较速度慢、实现成本较高，需要使用相联存储器（依据内容进行访问，哈希）
- 组相联映射：组间使用直接映射，组内采用全相联映射
  - 组内路数越大，发生冲突的概率越低，相联比较电路越复杂
  - 内存地址 = 标记 | 组号 | 块内地址
  - 组内路数 -> 组数 -> 组号长度 -> 标记长度
  - 路数越多，组数越少，组号长度越小，标记长度越长，cache 所需的空间开销越大  

Cache 的替换策略：

- 随机策略 (RAND)：随机选择进行替换，命中率较低
- 先进先出 (FIFO)：不能体现局部性
- **近期最少使用** (LRU)：使用近期最久没有访问过的数据进行替换
  - 使用计数维护历史使用信息，0 表示最近使用，len - 1 表示最久未使用
  - 新使用数据的计数置零，比其计数小的数据计数加 1，让出零位置
- 最不经常使用算法 (LFU)：访问一次计数加 1，替换计数最小的数据

Cache 的写策略：

- Cache 写命中的策略
  - 全写法（写直达，write-through）：写数据时同时写入 cache 和内存
    - 随时保证了内存的数据正确性，但增加了内存的访存次数，降低 cache 的效率
    - 引入写缓存解决内存和 cache 速度不匹配的问题
  - 写回法（write-back）：只修改 cache 的内容，当 cache 进行置换时写回内存
    - 减小了内存的访存次数，但存在数据不一致的隐患，并且需要增加一个脏位记录数据是否被修改的信息
- Cache 写不命中的策略
  - 写分配法（write-allocate）：加载数据到 cache，再更新数据
  - 非写分配法（not-write-allocate）：直接写入内存
- 全写法通常和非写分配法合用，写回法通常和写分配法合用
- 多级 cache 中，离 CPU 近的 cache 使用全写法，离 CPU 远的 cache 使用写回法

## 虚拟存储器

由内存和外存共同实现，具有内存的速度和外存的容量

- 在内存的实地址（物理地址）空间中，结合外存与内存进行数据交换，形成存储的虚拟空间（程序空间、虚拟地址）
  - 虚拟存储的空间取决于最大寻址位数与内存和外存的容量之和
- 内存可以看作虚存的缓存，（从数据调度的角度而言，）虚拟存储器对应用程序员而言是透明的

**页式虚拟存储器**：

- 虚拟地址 = 虚拟页号 | 页内地址
- 实页：对应主存的页；虚页：对应虚拟内存的页
- 实页号和虚页号通过页表进行映射
- 页表：由多个页表项构成，记录每一个虚页的信息
  - 有效位（装入位）：记录页面是否在主存当中
  - 脏位（修改位）：记录页面是否被修改，使用回写策略进行写操作
  - 引用位（使用位）：记录页面的使用信息，方便替换策略的进行
  - 物理页号：记录虚页在主存中的位置
  - 外存地址：记录页所在外存的物理块号
- 页表基址寄存器：每一个进程都具有，记录进程对应页表的首地址
- 优点：页面长度固定，调入简单方便
- 缺点：最后一页很可能存在存储碎片，每一页不是逻辑独立的实体不方便进行管理共享

快表 (TLB)：Cache 在虚存机制中的应用，避免访存次数增加造成效率降低

- 快表放在高速缓冲器 (cache) 中，慢表 (page) 放在内存中
- 同样需要标记标识对应的页表项，通常采用全相联方式或组相联方式

段式虚拟存储器：按照程序的逻辑结构划分**段**

- 虚拟地址 = 段号 | 段内地址
- 段表记录程序的各个逻辑段的信息，每个段段长可变
- 每个段记录包含有效位（装入位）、起始地址、段长
- 优点：逻辑独立，易于管理以及在多道程序之间进行共享
- 缺点：段长可变容易在空间留下碎片，造成空间浪费

段页式虚拟存储器：先按逻辑结构分段，再在每段进行分页

- 虚拟地址 = 段号 | 段内页号 | 页内地址，段的起点终点必须为页的起点终点
- 内存空间按页划分，数据传送以页为基本单位
- 一个程序对应一个段表，一个段对应一个页表存储其起始地址
- 兼具页式和段式虚拟存储器的优点，空间浪费小，易于管理和共享；但需要两次查表，系统开销较大
