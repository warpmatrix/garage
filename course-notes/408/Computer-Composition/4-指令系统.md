# 指令系统

## 指令格式

指令系统（指令集）：软硬交界

指令：操作码、地址码（可选）

- 不同的指令字长：单字长指令、半字长指令、双字长指令
- 指令字长是否固定分为：定长指令字结构、变长指令字结构
- 不同的地址码数量：0-4
  - 零地址指令，不需要操作数的指令：空操作指令、停机指令、关中断指令
  - 四地址指令：给出下一条执行指令的地址

不同的地址码数量的两种处理方式：

- 有不同的地址寻址范围，地址码数量越少寻址范围越大
- 操作码的位数不定（扩展操作码），不同的地址码数量都可以设置一定数量的操作码

扩展操作码：操作码的高位设置全 1 进行扩展，低位设置不同的数字代表不同的操作码

- 短的操作码不能是长的操作码的前缀，因此使用全 1 作为扩展
- 可以和哈夫曼编码进行对比，并且操作码之间不能重复

不同的指令类型：数据传送指令、算术和逻辑运算指令、意味操作指令、转移指令、输入输出指令

## 指令的寻址方式

寻址方式：寻找指令或数据的有效地址的方式，分别对应指令寻址和数据寻址

- 形式地址 (A)：指令中地址码不代表操作数的真实地址
- 有效地址 (EA)：形式地址结合寻址方式，计算出操作数在存储器的真实地址

指令寻址：

- 顺序寻址：通过程序计数器（PC）的自增，自动形成下一条指令的地址
- 跳跃寻址：通过转移指令，由当前指令给出下一条运行指令的地址，直接修改 PC 的值
  - 给出的地址可能为相对地址、绝对地址，受程序状态寄存器和操作数的影响

数据寻址：指令中给出操作数的地址，通常增加寻址特征字段

- 隐含寻址：指令中隐含操作数地址，如：ACC，有利于缩短指令字长
- 立即寻址：指令给出的形式地址为操作数本身（立即数）
  - 数据采用补码的形式存储，执行阶段无需访问主存，指令执行时间最短
  - 但形式地址的位数限制了立即数的取值范围
- 直接寻址：指令中的形式地址是操作数的真实地址，$EA = A$
  - 简单仅需一次访存无需专门计算地址
  - 但形式地址的位数决定了有效地址的取值范围
- 间接寻址：指令给出的形式地址为存储操作数**地址的**存储单元**地址**，$EA = (A)$
  - 可以一次或多次间接寻址，方便程序编写（递归）
  - 可以扩大寻址范围，但需要多次访存访问速度慢，通常使用寄存器寻址
- 寄存器寻址：指令中给出存储操作数的寄存器编号，$EA = R_i$
  - 无需访问主存，访问速度块，指令字长短，但寄存器个数有限
- 寄存器间接寻址：指令中给出存储操作数地址的寄存器编号，$EA = (R_i)$
  - 相比间接寻址，只需访问一次主存，速度更快
- 相对寻址：指令中的形式地址是当前指令（下一条未执行的指令）地址的偏移量，$EA = (PC) + A$
  - 偏移量由补码表示，可正可负，形式地址的位数决定了寻址范围
  - 用于程序的跳转，避免程序的移动导致代码需要修改
- 基址寻址：指令中的形式地址作为偏移量和基址寄存器 (BR) 的内容形成有效地址，$EA = (BR) + A$
  - 基址寄存器可以使用专门的寄存器，也可以使用通用寄存器，存储程序的起点作为起始地址（[重定位寄存器](../Computer-Composition/3.5-内存管理(os).md)）
  - 基址寄存器面向操作系统，基址寄存器的内容由操作系统或者管理程序决定，内容不会发生改变
  - 可以扩大寻址范围，用户不必考虑数据存放的绝对位置，用于实现多道程序便于程序在内存中进行移动，一般形式地址位数较小
- 变址寻址：指令中的形式地址作为基地址和变址寄存器 (IX) 的内容形成有效地址，$EA = A + (IX)$
  - 变址寄存器面向用户，内容可以由用户指定
  - 通常变址寄存器存储数组下标，用于遍历数组，$A$ 作为数组首地址
- 堆栈寻址：使用堆栈存取数据，使用堆栈指针进行相应的管理
  - 硬堆栈：寄存器堆栈，成本较高不适合作为大容量堆栈
  - 软堆栈：在内存中划分一个区域作为一个堆栈
  - 操作堆栈的指令表现为无操作数的指令，隐含地使用堆栈指针
- 基址寻址和变址寻址可以复合使用

## x86 汇编指令

相关寄存器：

- EAX（累加器）、EBX（基地址寄存器）、ECX（计数寄存器）、EDX（数据寄存器）
- ESI、EDI（变址寄存器）、EBI（堆栈基指针）ESP（堆栈顶指针）
- `E_X` (32 bit), `_X (_L, _H)` (16 bit)

数据传送指令：第一个参数为目的地址，第二个参数为源地址

数据类型长度声明：`DB`、`DW`、`DD`

- D: Data, B: Byte, W: Word, D: Double word

具体指令：mov, push, pop, add, sub, inc, dec, imul, idiv, add, or, xor, not, neg, shl, shr, jmp, j(cond), call, ret

## CISC 和 RISC

CISC: Complex Instruction Set Computer

- x86 架构，用于笔记本、台式机等
- 一条指令可以完成复杂的功能，各个指令之间差异较大
  - 使用频率、执行时间、指令长度、指令格式、指令实现
- 控制器使用微程序实现多数复杂指令
- 82 定律：80% 的语句使用的是 20% 的指令

RISC: Reduced Instruction Set Computer

- ARM 架构，主要用于手机、平板等
- 指令之间的差异不大：指令执行时间、指令字长相等，方便进行优化
- 指令执行时间相差不大，方便使用流水线、并行计算等技术
- 访问内存必须使用 `Load` 和 `Store`
- 控制器使用组合逻辑进行控制
