# 内存管理

不可能将所有用户进程和系统所需的全部程序和数据放入内存，需要进行合理划分和动态分配

内存管理的主要功能：

- 提高内存利用率，在逻辑上扩充内存
- 内存空间的分配和回收
- 逻辑地址和物理地址之间的地址转换
- 存储保护：隔离进程之间的相互影响

## 进程运行的基本原理

- 编译：将源代码编译为若干目标模块
- 链接：将目标模块和库函数等链接在一起，形成完成的装入模块
- 装入：将装入模块加载到内存中运行

链接的三种方式：

- 静态链接：在程序运行之前，直接链接形成可执行文件
- 装入时动态链接：加载到内存时，边装入边链接
- 运行时动态链接：程序执行需要目标模块时，才将对应的模块装入
  - 便于进行修改和更新，便于实现对目标模块的共享

装入内存的三种方式：

- 绝对装入：编译时生成绝对地址（内存的物理地址），不能对地址进行修改，只适用于单道程序环境
- 可重定位装入（静态重定位）：目标模块的地址使用相对地址，装入内存时一次性将相对地址转换为绝对地址
  - 装入内存分配要求的所有空间，并且运行时不能在内存中移动，也不能再申请内存空间
- 动态运行时装入（动态重定位）：装入内存使用相对地址，程序真正执行时才将相对地址转换为绝对地址，需要重定位寄存器的支持
  - 可以将程序分配到不连续的存储区中，便于程序段的共享，并且可以动态申请分配内存，可以提供比存储空间大的地址空间

逻辑地址空间和物理地址空间：

- 逻辑地址本质上是相对地址，物理地址是内存中的绝对地址
- 地址重定位：将逻辑地址映射到物理地址
- 不同的程序可以使用相同的逻辑地址，相同的逻辑地址被映射到不同的物理地址中
- 用户和应用程序员使用逻辑地址，物理地址的管理对用户透明

实现内存保护的两种方法：

- 上、下限寄存器：记录进程的上限和下限的地址和访问的地址进行比较
- 重定位寄存器和界地址寄存器：记录进程在内存中的起始地址和最大的逻辑地址
  - 界地址寄存器用于和逻辑地址进行比较，重定位寄存器用于物理地址的转换

## 连续的物理内存分配方式

单一连续分配方式：将内存分为系统区和用户区，只提供给一个进程使用

- 简单、无外部碎片，但有内部碎片且内存利用率低，无法用于多道程序系统

固定分区分配：提前将内存划分为固定大小的区域，选择合适的分区分配给进程

- 使用分区说明表记录相应的分区信息，记录分区大小、起始地址和状态信息
- 划分分区的两种方法：
  - 分区大小相等：缺乏灵活性，适合用于控制多个相同对象的场合
  - 分区大小不等：通常划分为多个小分区，适量中分区，少量大分区
- 可能由于划分区间过小而无法将大程序放入分区中
- 可能存在**内部碎片**，内存利用率低；不同进程使用一个分区，不能多进程共享内存分区

动态分区分配：依据进程大小动态建立分区大小

- 随着内存的使用产生很多细小的**外部碎片**，可以通过紧凑的方式解决，需要动态重定位寄存器的支持
- 存在四种分区分配算法：
  - 首次适应算法：在低地址部分产生很多小的空闲分区，每次查找都需要经过增加开销
  - 最佳适应算法：产生很小的内存碎片难以利用，外部碎片最多
  - 最坏适应算法：快速消耗大内存块，导致没有可用的大内存块
  - 邻近适应算法：导致内存的末尾分配空间分裂成小碎片

上述的方法将程序存放在连续的内存中。其中，固定分区产生内部碎片，动态分区产生外部碎片，内存利用率都比较低

## 非连续分配管理方式

按分区大小是否固定可以分为两种管理方式：分页存储管理方式、分段存储管理方式

基本分页存储管理方式：

- 进程中的分区称为页，内存中的分区称为页帧（页框），外存中的分区称为块
- 不会产生外部碎片，并且只有最后一个块才会产生内部碎片（页内碎片）
  - 平均每个进程产生半个块的内存碎片
- 页面大小需要适中，在时间效率和空间效率之间取得平衡
  - 页面大小过大，页内碎片增加，内存利用率降低
  - 页面大小过小，页面数过多页表过长，增加地址转换开销，降低页面的交换效率
- 同样可以使用具有并行查找能力的快表，加快地址变换速度
- 基本分页存储管理方式：将程序的整个逻辑地址空间都放入内存中
  - 进行基本地址变换：需要使用页表寄存器 (PTR)，存储页表起始地址和页表长度
  - 使用**多级页表**对程序使用的页建立索引，避免无用的页表项造成空间的浪费，同时减少顺序查找的时间开销

基本分段存储管理方式（基本分段存储管理方式）：机组中的段式虚拟存储器

- 对程序进行逻辑分段，方便进行内存共享、信息保护和动态链接等
- 内存空间段内连续，段间可以不连续
- 进程的地址空间是二维的，段号和段内偏移量需要由程序员或编译器显式提供
- 进行地址变换需要使用段表寄存器，存放段表起始地址和段表长度
  - 寻址先比较段号是否越界，再比较段内偏移是否越界

段页式管理方式：机组中的段页式虚拟存储器

- 使用段号、页号和页内偏移进行寻址
- 一个进程，段表只有一个，页表可能有多个
- 使用快表进行加速：标识由段号、页号组成，内容是帧页号和保护码

上述存储管理方式都是一次性将程序装入内存导致：

- 过大的程序可能无法装入内存运行
- 装入程序占用内存过多，只能少量程序先运行，导致多道程序度下降
- 除了程序运行完毕，程序将一直驻留在内存中，占用内存资源

## 虚拟内存管理

虚拟内存管理基于局部性原理：将程序使用的部分装入内存，并且可以通过调入、换出等操作置换内存数据，对用户完全透明。具有以下特点：

- 多次性：程序可以多次调入内存，无需一次性装入
- 对换性：程序在运行的过程中，可以进行调入和换出
- 虚拟性：可以在逻辑上扩充内存的容量，用户使用的存储容量由寻址长度决定

虚拟内存的实现方式：请求分页存储管理、请求分段存储管理、请求段页式存储管理

- 需要的支持：内存和外存、页表机制、中断机制、地址变换机制

请求分页管理方式：[机组存储系统](../Computer-Composition/3-存储系统.md)中的页式虚拟存储器

- 访问的页面不在内存产生缺页中断，将数据调入内存
- 进程存储量越少，内存中驻留的进程数越多，多道程序度越大，但缺页率会增加
- 进程存储量越多，缺页率越低，但由于局部性原理，存储量越大对缺页率的影响越不明显
- 缺页中断为内部中断，在指令执行期间产生；并且一条指令可能产生多次缺页中断
- 调入页面的过程可能进行页面置换操作

页面置换算法：不同的页面置换算法对性能的影响明显（对比 Cache 的替换策略）

- 最佳置换算法 (OPT)，离线算法：置换未来最长时间内不被访问的页面，用于评价其他算法
- 先进先出算法 (FIFO)：置换在内存中滞留时间最久的页面
  - 可能有部分页面需要经常访问但被换出，不符合进程运行的规律
  - 可能出现 Belady 现象：分配物理块数的增加，反而导致缺页数增加
  - 命中意味着不是作为最新页面，在后续的访问中更可能被置换出去
- 最近最久未使用算法 (LRU)：置换最近最长时间没有被访问的页面
  - 每个页面需要设置访问字段，记录历史的访问信息
  - 需要寄存器和栈的硬件支持，实现开销比较大比较困难
  - 不会出现 Belady 现象
- 时钟置换算法 (CLOCK)，最近未用算法 (NRU)：
  - 引入**访问位**，循环检查页面使用情况，置换最近未使用的页面
  - 一些改进：引入**修改位**，优先选择没有进行修改的页面进行替换

页面分配策略（分配的页面来源）

- 固定分配局部置换：每个进程分配一定数量的物理块，在进程中选择页面进行置换
  - 难以确定每个进程所需的物理块数量，数量过多过少均不合适
- 可变分配全局置换：进程缺页在系统中分配新的物理块
  - 能动态增加进程的物理块数量，但盲目增加进程的物理块导致系统的多道程序度下降
- 可变分配局部置换：维持进程缺页率在一个适当的范围
  - 动态增加和减少进程的物理块数量，避免过高缺页率的同时保持了系统的多道程序并发能力
  - 需要更大的开销和更复杂的实现

页面调度的时机策略：

- 预调页策略：根据局部性原理，一次调入若干相邻的页
  - 以预测为基础，预测成功率不高，主要用于进程的运行前调入
- 请求调页策略：根据进程请求进行调度，每次仅调入一页
  - 可能导致过高的 IO 开销，主要用于进程运行期间调入

被调入圆面的来源（外存的分类）：对换区 (swap)（连续的分配方式，读写更快）、文件区（离散的分配方式）

- 拥有足够的对换区空间：将进程用到的文件从文件区复制到对换区从对换区调入
- 缺少足够的对换区空间：不会被修改的文件留在文件区调入；修改的文件调出时调到对换区以后使用从对换区调入
- UNIX：未运行过的文件从文件区调入，运行过的文件从对换区调入

抖动和颠簸：频繁地进行页面调度操作（刚刚换出的页面马上换入内存）

- 主要原因：进程访问的页面数高于内存的页帧数，导致换页的时间很可能多余执行时间

工作集：在一个时间间隔内，进程访问的页面集合（可以通过最近访问的页面确定工作集）

- 根据局部性原理，工作集大小比工作集窗口小很多
- 落在工作集内部的页面调入内存，落在工作集外部的页面换出内存
